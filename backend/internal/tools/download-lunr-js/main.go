package main

import (
	"bytes"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
	"time"
)

const url = "https://unpkg.com/lunr@v2.3.9/lunr.js"
const checksum = "9431726f05c0eae2a6e54dc197709422869f25cad44f2430d2fb7ddae80cc717"

var templateText = `// Code generated by internal/tools/download-lunr-js. DO NOT EDIT.

package {{ .Package }}

//go:generate go run github.com/opentofu/registry-ui/internal/tools/download-lunr-js -file {{ .File }} -package {{ .Package }}

var lunrJSCode = ` + "`{{ .Code }}`\n"

func main() {
	pkg := ""
	file := ""

	flag.StringVar(&pkg, "package", pkg, "Go package name")
	flag.StringVar(&file, "file", file, "Target file name")
	flag.Parse()

	data, err := download()
	if err != nil {
		log.Fatal(err)
	}
	if err := checkChecksum(data); err != nil {
		log.Fatal(err)
	}
	rendered, err := renderTemplate(pkg, file, data)
	if err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile(file, rendered, 0644); err != nil {
		log.Fatal(err)
	}
}

func renderTemplate(pkg string, file string, data []byte) ([]byte, error) {
	tpl := template.New("")
	var err error
	tpl, err = tpl.Parse(templateText)
	if err != nil {
		return nil, err
	}
	wr := &bytes.Buffer{}
	if err := tpl.Execute(wr, struct {
		Package string
		File    string
		Code    string
	}{
		pkg, file, strings.ReplaceAll(string(data), "`", "` + \"`\" + `"),
	}); err != nil {
		return nil, err
	}
	return wr.Bytes(), nil
}

func download() ([]byte, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
	defer cancel()
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}
	response, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = response.Body.Close()
	}()
	if response.StatusCode != 200 {
		return nil, fmt.Errorf("invalid status code %d", response.StatusCode)
	}
	return io.ReadAll(response.Body)
}

func checkChecksum(data []byte) error {
	hash := sha256.New()
	hash.Write(data)
	hexChecksum := hex.EncodeToString(hash.Sum(nil))
	if hexChecksum != checksum {
		return fmt.Errorf("incorrect checksum: %s", hexChecksum)
	}
	return nil
}
